\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry} 
\usepackage{amsmath,amsthm,amssymb,amsfonts}
\usepackage{graphicx} 
\usepackage{enumitem}
\usepackage{multicol}
\usepackage{color}

\newcommand{\todo}[1]{\textcolor{red}{#1}}

\newenvironment{problem}[2][Problem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
%If you want to title your bold things something different just make another thing exactly like this but replace "problem" with the name of the thing you want, like theorem or solution or whatever

\setlength\parindent{0pt}



\title{CS 181U Applied Logic HW 1 \\ Due Wednesday Feb 5, 2020}
\date{2/5/20}
\author{Caroline Tandrup}
\begin{document}
\maketitle

 
\begin{problem}{1} In class, we discussed some challenges that come from discrepancies between the way formal logic works and the way we use logical connectives in everyday natural language. This problem will explore that a little bit more.  

\begin{enumerate}[label=\Alph*.]

\item \textbf{Unless.} We use the word `unless' all the time. For instance, I might say ``I'm going on vacation \textit{unless} I get a cold.''


\begin{enumerate}[label=\roman*.]

\item Let the symbol $\mathrm{U}$ represent the `unless' operator; we write $A \mathrm{U} B$ to express the sentence `$A$ unless $B$'. Fill in this truth table for the unless connective for what you think the word `unless' means in natural language. (I.e. replace the question marks with $T$ or $F$.) There isn't really a right or wrong answer. I'm truly just asking you what you think, but you should be able to back up your reasoning if I were to ask. \\

\begin{center}
\begin{tabular}{|c|c||c|}
\hline
$A$ & $B$ & $A \ \mathrm{U} \ B$ \\ \hline \hline
$F$ & $F$ & $F$ \\ \hline
$F$ & $T$ & $T$ \\ \hline
$T$ & $F$ & $T$ \\ \hline
$T$ & $T$ & $F$ \\ \hline
\end{tabular} \\ 
\end{center} 

~ \\

\item Express the semantics that you ascribed to `unless' using only the logical connectives from among $\land, \lor, \rightarrow, $ and $\neg$. \\

\textbf{Answer.}  

$A \mathrm{U} B \equiv (\neg B \land A) \lor (\neg A \land B)$

\newpage 

\item If, in addition to the logical connectives from part (ii), you can also use connectives from among $\bar\land$ (NAND), $\bar\lor$ (NOR), and $\oplus$ (XOR), what is the smallest formula that you can write that is equivalent to $A \ \mathrm{U} \ B$ \ ? \\

\textbf{Answer.} 

$A \mathrm{U} B \equiv A \oplus (XOR) B$


\item Imagine that the \textit{unless} operator, $\mathrm{U}$, became a standard operator in formal propositional logic. In your opinion, do you think that the word `unless' as understood and used in natural language and a formal semantics of the unless operator $\mathrm{U}$ would have any important differences? Why or why not? \\

\textbf{Answer.} 

Yes, I do think there are important differences between the natural language use of the word "unless" and the formal propositional logic use. The most obvious and important one to me seems to be the distinction that in common natural language uses of "unless" we usually mean that if the clause following "unless" is true, the first part is false, and if the second part is false, the first part is true. However, in terms of formal propositional logic, the word "unless" seems to mean more that if the second clause is true, the first part better be false, but if the second part is false, we don't actually know whether the first clause should be true or not (it's not specified bidirectionally). In formal logic, I would expect the truth table to look more like something below:

\begin{center}
\begin{tabular}{|c|c||c|}
\hline
$A$ & $B$ & $A \ \mathrm{U} \ B$ \\ \hline \hline
$F$ & $F$ & $T$ \\ \hline
$F$ & $T$ & $T$ \\ \hline
$T$ & $F$ & $T$ \\ \hline
$T$ & $T$ & $F$ \\ \hline
\end{tabular} \\ 
\end{center} 

\end{enumerate}


\newpage
\item \textbf{More on Biscuit Conditionals.} In class we talked about so-called `Biscuit conditionals'. We observed that when somebody says ``If you are hungry, there are biscuits on the table,'' it doesn't really have the same meaning when we try to interpret the sentence using the semantics of the propositional logic operator $\rightarrow$.

For this question, your goal is to explain to another person (a friend, student in another course, a sibling, anybody) the discrepancy that arises in trying to interpret conditional natural language sentences using formal logic. But, importantly, try not to be a jerk about it.

\begin{center}
\includegraphics[scale=0.7]{conditionals.png}
\end{center}

Write one to two paragraphs describing your experience with explaining the idea of biscuit conditionals to another person.

\textbf{Answer.} 

In terms of natural language, we frequently use words that have formal propositional logic implications, without much concern regarding the translation. If you say to someone, "If you're hungry, there are biscuits on the table, 99% of people will understand that you mean to say that there are biscuits on the table that you are welcome to eat if you're hungry. However, the propositional interpretation of this statement uses the "implies" logical operator which implies the following: If you are hungry, then there will be biscuits on the table, and are guaranteed to be biscuits on the table. If you are not hungry, there could be biscuits on the table, but there also might not be. There is nothing telling us about the biscuit-on-table situation if you're not hungry. We all probably agree that this is not the meaning of the natural language saying, since we don't mean to say biscuits will appear if you're hungry and may or may not if you're not hungry. This discrepancy is well explained by the biscuit problem but follows in so many other natural language to formal logic translations.\\ 
The overall idea here is that we can't interchangably use words in natural language and formal logic without some careful consideration of the differences between the two. It's very tempting to assume that we can talk about propositional logic using natural language examples, since it's often easier to think about than trues and falses. A really good example of this is the semantic use of the word "or". In natural language we usually mean exclusive or, in the sense that one or the other but not both is true, however, in propositional logic "or" is still true when both cases apply. IT's difficult to see how to work around this issue without just being incredibly explicit about what use we want. To people who haven't excessively studied propositional logic, it may seem like the semantics just consider every sentence a little too literally, but it's very important to understand that both are valid interpretations and rather clarity is the necessary link to figure out what exactly our words mean. It is interesting that within the English language, we can understand each other even if we don't use formal rules when using words like "and","or","unless",etc.\\ 

\end{enumerate}

\end{problem}


% \newpage 
% \begin{problem}{2} WFF Structural Induction

% \end{problem}


\newpage

\begin{problem}{2} \textbf{A Python-based Logic Language} \\

In this problem you will implement several fundamental operations for propositional logic. \\

\textbf{Provided Starter Code} \\

The file \texttt{propositional\_logic.py}, which you hopefully recall from last week, contains several class definitions for defining expressions in propositional logic. For instance, to encode the formula 
$A \rightarrow (B \land \neg C)$, 
we would write \\

\texttt{Implies(BoolVar(`A'), And(BoolVar(`B'), Not(BoolVar(`C'))))} \\

where \texttt{Implies}, \texttt{And}, \texttt{Not}, and \texttt{BoolVar} are all object constructors. \\

\textbf{Operations on Logical Formulas} \\

Given an object, say \texttt{F}, for a logical formula, we want to perform some useful operations on it. For instance, we may want to get the set of all variables in \texttt{F} or evaluate it under some interpretation, \texttt{I}, of those variables. To perform these operations, we will make method calls, like \texttt{F.getVars()} or \texttt{F.eval(I)}. \\



For this problem, we will focus on these important operations: \\

\begin{itemize}
\item \texttt{isAtom} checks if \texttt{F} is an atom.
\item \texttt{isLiteral} checks if \texttt{F} is a literal.
\item \texttt{getVars} returns a list of all variables in \texttt{F}.
\item \texttt{isNNF} checks if \texttt{F} is in negation normal form.
\item \texttt{eval} evaluates \texttt{F} under an interpretation.
\item \texttt{NNF} returns the negation normal form of \texttt{F}.
\item \texttt{removeImplications} returns a formula equivalent to \texttt{F} without conditionals.
\item \texttt{simplify} returns a simplified version of \texttt{F}.
\end{itemize}

\newpage

\textbf{Provided Testing Code} \\

Along with the starter code, you also have 
\texttt{test\_propositional\_logic.py}. On the command line, inside the starter code directory, using the CS181u Docker, you can run the command \texttt{pytest} to run all of the tests in the testing file. The \texttt{pytest} command just looks in the current directory for files that start with \texttt{test\_} and runs all tests in those files that begin with \texttt{test\_}. \\

Initially, most of the tests will just fail since many things are not yet implemented. What will probably be more useful to you is to run a specific test function while you are developing a particular function. To do so you can, for example, run \\

\texttt{pytest -k test\_isNNF} \\

to run just the \texttt{test\_isNNF()} function. \\


\textbf{Provided Usage Code} \\

Along with the starter code and testing code, you have a file \texttt{using\_propositional\_logic.py}. This file shows some very basic usage of functions from \texttt{propositional\_logic.py}. You may find it useful to edit this file and try things out while you are developing. This file will not be graded. 


\newpage 

\begin{enumerate}[label=\Alph*.]

\item \textbf{Implement} \texttt{isLiteral}. \\

Use the following definitions to implement the \texttt{isLiteral} function. 

\begin{itemize}
	\item An \textit{atom} is either a constant or a variable. 

	\item A \textit{literal} is either an atom or the negation of an atom. 
\end{itemize}

For a propositional formula object \texttt{F}, calling \texttt{F.isLiteral()} should return \texttt{True} if and only if \texttt{F} is a literal, and \texttt{False} otherwise. \\

Here are several examples in python syntax: \\

\texttt{BoolConst(True).isLiteral() == True} \\
\texttt{BoolConst(False).isLiteral() == True} \\
\texttt{BoolVar('A').isLiteral() == True} \\
\texttt{Not(BoolVar('A')).isLiteral() == True} \\
\texttt{Not(BoolConst(True)).isLiteral() == True} \\
\texttt{And(BoolVar('A'), BoolVar('B')).isLiteral() == False} \\ \\

The equivalent expressions in the syntax of propositional logic that are literals: \\


$T$, $F$, $A$, $\neg A$, $\neg T$ \\

This is not a literal: \\

$(A \land B)$ \\


\item \textbf{Implement} \texttt{getVars}. \\


For any formula \texttt{F}, \texttt{F.getVars()} should return a list of all unique BoolVars in the expression. there should not be duplicates. \\

Example: \texttt{f1 = Iff(And(A,Or(B,T)), C)} \\ \\

\texttt{f1.getVars()} should return \texttt{[BoolVar(A), BoolVar(B), BoolVar(C)]} \\ \\

Example: \texttt{f2 = And(T,Iff(F,T))} \\ 
\texttt{f2.getVars()} should return \texttt{[] \# empty list}

\item \textbf{Implement} \texttt{isNNF}. \\

An expression is in NNF if all negations (if there are any) are ``at the lowest'' level and does not contain and conditionals. That is, negations only occur on atoms. For example, all of these formulas are in negation normal form:

$T$, 
$F$, 
$A$, 
$\neg T$, 
$\neg A$, 
$(A \land B)$, 
$(A \Leftrightarrow T)$, 
$(\neg C \lor A)$, 
$((((B \lor \neg F) \lor (P \lor \neg T)) \lor \neg A) \land (\neg T \lor \neg F))$ \\

These formulas are not in negation normal form: \\

$\neg \neg A$, 
$(\neg \neg T \land \neg A)$,
$\neg (A \land B)$ \\ 


\textbf{NOTE:} This is one place where you might want to use \texttt{isinstance(self.exp, Not)} to check for two layers of negations. If you really love OOP and want to try to attempt a solution based on `double dispatch', be my guest!



\item \textbf{Implement} \texttt{removeImplications}. \\



We can use these equivalences to remove implications from a formula so that  it only has $\land, \lor, \neg$, and atomic expressions: \\ \\

$A \rightarrow B \equiv \neg A \lor B$ \\

$A \leftrightarrow B \equiv (A \rightarrow B) \land (B \rightarrow A)$ \\ 

Examples: \\ 

\texttt{f1 = Not(Implies(A,Or(C,B)))} 

\texttt{f1.removeImplications()} returns 

\texttt{Not(Or(Not(BoolVar(A)), Or(BoolVar(C), BoolVar(B))))} \\ 

\texttt{f2 = Iff(Not(BoolVar(A)), Or(BoolVar(C), BoolVar(B)))} 

\texttt{f2.removeImplications()}  returns

\texttt{Or(And(Not(BoolVar(A)), Or(BoolVar(C), BoolVar(B))), And(Not(Not(BoolVar(A))), Not(Or(BoolVar(C), BoolVar(B)))))} 


\newpage


\item \textbf{Implement} \texttt{NNF}. \\

An expression can be converted to NNF by first removing all implications and then recursively applying equivalences: \\

$\neg \neg A \equiv A$

$\neg (A \land B) \equiv (\neg A \lor \neg B)$

$\neg (A \lor B) \equiv (\neg A \land \neg B)$ \\


Each equivalence provides a way to either eliminate a negation at the outer level, or to move it down from one level into a lower level sub-formula. \\ \\

\textbf{NOTE:} This is the other place where you might want to use \texttt{isinstance(self.exp, Not)} to check for two layers of negations. If you really love OOP and want to try to attempt a solution based on `double dispatch', be my guest!

\item \textbf{Implement} \texttt{eval}. \\



In our python implementation of Boolean logic, an interpretation is a dictionary from variables to values. \\ \\

Example:  \\

\texttt{interp = {BoolVar('A') : BoolConst(True), BoolVar('B'): BoolConst(False)}} \\ \\

\texttt{f.eval(interp)} should evaluate \texttt{f} under the interpretation. \\ \\

Example: \\

\texttt{And(BoolConst(False), BoolVar('A')).eval(interp)} 

should return \texttt{BoolConst(False)}


\newpage

\item \textbf{Implement} \texttt{simplify}. \\

Often, it is useful to simplify a formula based on the semantics that we know. For example, we might want to simplify $A \lor A$ into just $A$. In this part, I am asking you to implement all of the following simplification rules.


\begin{minipage}[t]{0.33\textwidth}
\vspace{0pt}
\textbf{Negations} \\

$\neg T \equiv F$

$\neg F \equiv T$

$\neg \neg X \equiv X$ \\ \\ \\ \\

\textbf{Biconditionals} \\

$T \leftrightarrow X \equiv  X $

$X \leftrightarrow T \equiv  X $

$F \leftrightarrow X \equiv \neg X $

$X \leftrightarrow F \equiv \neg X $

$X \leftrightarrow X \equiv T $
 




\end{minipage}
\begin{minipage}[t]{0.33\textwidth}
\vspace{0pt}

\textbf{Disjunctions} \\


$T \lor X \equiv T$

$X \lor T \equiv T$

$F \lor X \equiv X$

$X \lor F \equiv X$

$X \lor X \equiv X$ \\ \\


\textbf{Implications} \\

$T \rightarrow X \equiv  X$

$F \rightarrow X \equiv  T$

$X \rightarrow X \equiv  T$

$X \rightarrow T \equiv  X$

$X \rightarrow F \equiv \neg X $



\end{minipage}
\begin{minipage}[t]{0.33\textwidth}
\vspace{0pt}

\textbf{Conjunctions} \\

$T \land X \equiv X$

$X \land T \equiv X$

$F \land X \equiv F$

$X \land F \equiv F$

$X \land X \equiv X$

\end{minipage} \\ \\ \\

\textbf{Examples and testing simplify.}
In this part of the assignment I am asking you to come up with your own examples and tests. You should fill in at least 5 tests for the \texttt{test\_simplify()} function in the \texttt{test\_propositional\_logic.py} file. \\ \\


\textbf{NOTE:} This is the last place where you might want to use \texttt{isinstance(self.exp, Not)} to check for two layers of negations. If you really love OOP and want to try to attempt a solution based on `double dispatch', be my guest!


\end{enumerate}

\end{problem}